\section{Die For-Schleife \\ \footnotesize Einen Programmabschnitt x-mal ausführen}

\begin{frame}

\begin{block}{Problemstellung}
\vspace{2pt}
Lies eine ganze Zahl \py{x} ein. Gib dann folgende Zeilen auf der Konsole aus 

\texttt{1}\\
\texttt{2}\\
\texttt{3}\\
\texttt{4}\\
\vdots \\
\texttt{x}

\vspace{12pt}
Wie macht man das? 

\end{block}
\end{frame}

\begin{fragile}{}
	\begin{block}{Lösung}
		\begin{minted}{python}
			x = input("Enter a number")
			
			for k in range(1, x + 1):	
			  print(k)
		\end{minted}
	\end{block}
\end{fragile}

\begin{frame}

	\renewcommand{\baselinestretch}{1.5}
	\metroset{block=fill}
	\begin{block}{Struktur der \texttt{for...in} Schleife}
		\vspace{2pt}
		\pause \py{for} \pause \textit{Variable} \pause \py{in} \pause \py{range}(\textit{min}, \textit{max})\pause\texttt{:} \pause \\
		\spacechar\spacechar Codezeile 1 \pause \\ 
\spacechar\spacechar Codezeile 2 \pause \\
\spacechar\spacechar \phantom{Code} \vdots \pause  \\
\textit{Code, der nicht mehr Teil der Schleife ist}
	\end{block}

\vspace{12pt}
\pause 

\metroset{block=transparent}
	\renewcommand{\baselinestretch}{1}
	\begin{block}{Wie funktioniert's?}
		\vspace{2pt}
	Die Schleifenvariable wird zunächst gleich dem unteren Wert in \py{range} gesetzt. Dann wird der \pybw{for}-Block wiederholt ausgeführt. Bei jedem Durchgang wird die Schleifenvariable um \pybw{1} vergrößert und zwar so lange, wie der Wert der Schleifenvariable kleiner als der obere Wert in \py{range} ist. 	
	\end{block}
\end{frame}

\begin{frame}
\begin{block}{Good to know}
	\pause
	\begin{itemize}[<+->]
		\item Achtung: Die Schleifenvariable erreicht nie das obere Ende der \py{range}-Funktion, sondern bleibt immer \pybw{1} drunter. 
		\item Die \py{range}-Funktion ist nicht auf 1er-Schrittweite beschränkt. Mit folgendem Ausdruck werden die Zahlen von \py{0} bis \py{9} z.B. in 3er-Schritten durchlaufen: \py{range(0, 10, 3)}. 
		\item \texttt{For}-Schleifen sind flexibel und können alles mögliche durchlaufen, z.B. auch die einzelnen Buchstaben eines Strings (dazu später mehr).
	\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Übung}

\begin{block}{Einmaleins: Die 7er-Reihe}
	\vspace{2pt}
Schreibe ein kleines Skript, was die 7er-Reihe (bis 70) wie folgt auf der Konsole ausgibt: 

\texttt{1 mal 7 ist 7}\\	
\texttt{2 mal 7 ist 14}\\
\phantom{4 mal} \vdots  

\end{block}

\vspace{12pt}

\pause 

\begin{block}{7er-Reihe mit beliebigem oberen Ende}
\vspace{2pt}
Lies eine positive ganze Zahl \py{x} ein und gib die 7er-Reihe von \py{7} bis mindestens \py{x} wie oben auf der Konsole aus.
\end{block}

\pause

\vspace{12pt}

\begin{block}{Schleife über einen String}
\vspace{2pt}
Lies Deinen Namen (oder irgendein Wort) auf der Konsole ein und überprüfe, ob er den Buchstaben \emph{a} (groß/klein) enthält. 
\end{block}
\end{frame}


\begin{frame}{Schwierigere Übungen}

\begin{block}{Das Gauss-Problem}
\vspace{2pt}	
Berechne die Summe der Zahlen 1 bis 100. 
\end{block}
\vspace{12pt}
\pause

\begin{block}{Fibonacci-Zahlen}
	\vspace{2pt}
Die Zahlenfolge $1,1,2,3,5,8,13\ldots$ nennt man \emph{Fibonacci}-Folge. Dabei ensteht ein Element der Folge, durch die Addition des vorherigen und vorvorherigen Elements. 

\vspace{1pt}

Berechne die 30. Fibonacci-Zahl.  
\end{block}

\end{frame}

\begin{frame}{Harte Übungen}

\begin{block}{Quersumme}
	\vspace{2pt}
	Lies eine ganze Zahl \py{x} ein und bestimme ihre Quersumme. 
	
	\textbf{Tipp 1:} Die Anzahl der Stellen einer Zahl bekommt man mittels \py{len(str(x))} heraus. \\
	\textbf{Tipp 2:} Man benötigt Tipp 1 gar nicht.  
	
\end{block}

\vspace{12pt}
\pause

\begin{block}{Zahlenmuster}
	\vspace{2pt}	
	Gib folgendes Muster auf der Konsole aus: 
	
	\texttt{1} \\
	\texttt{1 2} \\
	\texttt{1 2 3} \\
	\texttt{1 2 3 4} \\
	\phantom{1 2 } \vdots \\
	\texttt{1 2 $\cdots$ 20}
\end{block}


\end{frame}


\section{Die While-Schleife \\ \footnotesize Wie die For-Schleife nur abstrakter und open-end}

\begin{frame}
\begin{block}{Problemstellung}
	\vspace{2pt}
	Lies immer wieder eine Zahl von der Konsole ein. Höre auf, wenn diese Zahl 7 ist. 
	
	Wie macht man das? 
\end{block}
\end{frame}

\begin{fragile}
	
\begin{block}{Lösung}
		\vspace{2pt}
		
	\begin{minted}{python}
		x = 0
		
		while x != 7: 
		  x = input("Enter a number")
		  x = int(x)
		  
		print("Yeah, you picked the right number.")
	\end{minted}
	
\end{block}
\end{fragile}


\begin{frame}

\renewcommand{\baselinestretch}{1.5}
\metroset{block=fill}
\begin{block}{Struktur der \texttt{while}-Schleife}
	\vspace{2pt}
	\pause \py{while} \pause \textit{Bedingung}\pause\texttt{:} \pause \\
	\spacechar\spacechar Codezeile 1 \pause \\ 
	\spacechar\spacechar Codezeile 2 \pause \\
	\spacechar\spacechar \phantom{Code} \vdots \pause  \\
	\textit{Code, der nicht mehr Teil der Schleife ist}
\end{block}
\vspace{12pt}
\pause 
\metroset{block=transparent}
\renewcommand{\baselinestretch}{1}
\begin{block}{Wie funktioniert's?}
	\vspace{2pt}
	Die Schleife wird solange ausgeführt, solange die \emph{Bedingung} \py{True} ergibt. Nach jedem Durchgang wird der Ausdruck der \emph{Bedingung} neu ausgewertet. 
	Ist die Bedingung \py{False} wird der Code unterhalb des Schleifenblocks ausgeführt. 
\end{block}

\end{frame}

\begin{frame}
\begin{alertblock}{Achtung Endlosschleife}
	\vspace{2pt}
	Man sollte immer darauf achten, dass die Bedingung in der \pybw{while}-Schleife auch wirklich irgendwannmal \py{False} wird. Ansonsten bleibt das Programm in einer \emph{Endlosschleife} gefangen. 
\end{alertblock}
\end{frame}

\begin{frame}{Übung}

\begin{block}{Ersetze eine \pybw{for}-Schleife durch eine \pybw{while}-Schleife}
\vspace{2pt}
Schreib ein Programm, dass alle 7er-Zahlen von 7 bis 700 auf der Konsole ausgibt.  
\end{block}

%\pause 
%\vspace{12pt}

%\begin{block}{Bestätigungsdialog \emph{deluxe}}
%\vspace{2pt}
%Verbessere den Bestätigungsdialog:  

%\texttt{Are you sure to continue? (y)es/(n)o}. 

%Mögliche Antworten sind \texttt{yes}, \texttt{no} bzw. \texttt{y}, \texttt{n}. 

%Daraufhin soll auf der Konsole \texttt{continued} oder \texttt{aborted} erscheinen. 
%Falls die Eingabe nicht klar erkannt wird, soll die Frage nochmal auf der Konsole gestellt werden. 

%Zum Beispiel: 
%\texttt{Please enter either "yes"{} or "no"}  
%\end{block}

\end{frame}

\begin{frame}{Übung}

\begin{block}{Notenrechner}
\vspace{2pt}
Schreib ein Programm, dass wiederholt nach einer Note von Dir fragt und Dir dann jeweils die aktuelle Durchschnittsnote auf der Konsole ausgibt. 
Das Programm soll durch die Eingabe vom Buchstaben \textbf{q} beendet werden können. 

Beispielausgabe: 

\texttt{Bitte gib eine Note oder q zum Beenden ein:} \py{1} \\
\texttt{Deine Durchschnittsnote ist 1.0} \\
\texttt{Bitte gib eine Note oder q zum Beenden ein:} \py{2} \\
\texttt{Deine Durschnittsnote ist 1.5} \\
\phantom{Code} \vdots 
	
\end{block}

\end{frame}

\begin{frame}{Übung}

\begin{block}{Ratespiel}
\vspace{2pt}
Definiere eine positive ganze Zahl \pybw{number_to_guess}. Der User kann nun wiederholt eine Zahl eingeben. Das Spiel endet, wenn die eingegebene Zahl mit \pybw{number_to_guess} übereinstimmt. 
Andernfalls wird auf der Konsole beispielsweise ausgegeben: 

\texttt{Sorry, Deine eingegebene Zahl war zu klein, versuche es nochmal: }

\pause
\textbf{Zusatz 1:} \\
Am Ende soll die Anzahl der Versuche angegeben werden.

\pause
\textbf{Zusatz 2:} \\
Das Spiel soll mit der Eingabe von \pybw{q} abgebrochen werden können. 

\pause
\textbf{Zusatz 3:} \\
Google, wie Python die Zahl \pybw{number_to_guess} zufällig erzeugen kann (das verbessert das Gameplay).  

\end{block}

\end{frame}

\section{\texttt{break} und \texttt{continue} \\ \footnotesize Den Fluss kontrollieren}


\begin{fragile}
	
\metroset{block=fill}

\begin{block}{Das \texttt{break}-Statement}
Taucht innerhalb einer Schleife das Schlüsselwort \py{break} auf, so wird die weitere Abarbeitung der Schleife abgebrochen. Die Ausführung wird mit dem Code \emph{nach} dem Schleifenblock ausgeführt. 		
\end{block}

\metroset{block=transparent}

\vspace{12pt} \pause 


\begin{exampleblock}{Beispiel}
\vspace{2pt}

\begin{overprint}
	\onslide<2|handout:0>
\begin{minted}{python}
for k in range(1,100):
  print(k)
  if k > 3:
    break
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
for k in range(1,100):
  print(k)
  if k > 3:
    break
# prints 1 2 3 4 
\end{minted}
\end{overprint}

\end{exampleblock}

	
\end{fragile}



\begin{fragile}
	
\metroset{block=fill}

\begin{block}{Das \texttt{continue}-Statement}
Taucht innerhalb einer Schleife das Schlüsselwort \py{continue} auf, so wird der aktuelle Schleifendurchgang abgebrochen. Die Ausführung wird mit der nächsten Schleifeniteration fortgesetzt. 
\end{block}

\metroset{block=transparent}

\vspace{12pt} \pause 


\begin{exampleblock}{Beispiel}
\vspace{2pt}

\begin{overprint}
\onslide<2|handout:0>
\begin{minted}{python}
for k in range(1,11):
  if k % 2 == 0:
    continue
  print(k)
\end{minted}
\onslide<3|handout:1>
\begin{minted}{python}
for k in range(1,11):
  if k % 2 == 0:
    continue
  print(k)
# prints 1 3 5 7 9 
\end{minted}
\end{overprint}
\end{exampleblock}
	
	
\end{fragile}


\begin{fragile}
	
\metroset{block=fill}

\begin{block}{Der \texttt{else}-Block einer Schleife}
Analog zum \py{if}-Statement, kann auch eine Schleife einen \py{else}-Block haben. Dieser wird ausgeführt, wenn die Schleife \emph{regulär} (also nicht durch die Verwendung von \py{break}) beendet wird.  
\end{block}

\metroset{block=transparent}

\vspace{12pt} \pause 


\begin{exampleblock}{Beispiel}
\begin{minted}{python}
name = input("Your name: ")

for letter in name: 
  if letter == "a":
    print("Your name contains an a")
    break
else: 
  print("Your name contains no a")
\end{minted}
\end{exampleblock}
	
	
\end{fragile}



\begin{frame}{Übung}
	
	\begin{block}{Die nächste 31er-Zahl}
		\vspace{2pt}
		Lies eine ganze Zahl \pybw{x} ein. Prüfe, ob unter den ersten 20 auf \pybw{x} folgenden Zahlen eine durch 31 teilbar ist. Gib sie in diesem Fall auf der Konsole aus, ansonsten gib aus, dass keine 31er-Zahl gefunden wurde.  
	\end{block}	

\end{frame}

\begin{frame}{Schwierigere Übung}
\begin{block}{Primzahltest}
\vspace{2pt}
Lies eine ganze Zahl \py{x} ein und überprüfe, ob diese Zahl eine Primzahl ist. Die Ausgabe des Programms soll etwa wie folgt aussehen:  

\texttt{Die Zahl 28061983 ist eine Primzahl.}
\end{block}
\end{frame}

\begin{frame}{Harte Übung}
\begin{block}{Finde die nächste Primzahl}
\vspace{2pt}
Lies eine ganze Zahl \py{x} ein und finde die nächste Zahl größer \py{x}, die gleichzeitig eine Primzahl ist. 
\end{block}
\end{frame}


\section{Listen \\ \footnotesize Viele Variablen gleichzeitig speichern}


\begin{frame}
\begin{block}{Problemstellung}
\vspace{2pt}
Gib wie im Notenrechner nacheinander Schulnoten von Dir ein. 
Alle Noten sollen gespeichert werden. Danach sollst Du die Wahl haben, die soundsovielte Note anzeigen lassen zu können.   

	\vspace{8pt}

Wie macht man das? 
\end{block}
\end{frame}

\begin{fragile}{}
\begin{block}{Lösung \footnotesize(fast)}
\begin{minted}{python}
...
# Um das Eingeben der Noten kümmern wir uns noch
grades = [12, 10, 7, 14, 13, 13, 6, 4, 15, 14] # Noten in Notenpunkten

index = input("Die wievielte Note möchtest Du nochmal anschauen?")
index = int(index)

print(f"Deine { index }. Note ist { grades[index] } Punkte")
\end{minted}
\end{block}
\end{fragile}


\begin{fragile}

\metroset{block=fill}
\begin{block}{Struktur einer \emph{Liste}}
\vspace{2pt}
\large
\texttt{my\_list = }\pause {\Large\texttt{[}}\pause 
\emph{Element0}\pause,
\pause 
\emph{Element1}, \pause 
\emph{Element2}, \pause 
 \dots   
, \emph{ElementN}\pause \Large{\texttt{]}}
\end{block}

\pause 

Die Variable \texttt{my\_list} trägt nicht nur einen Wert, sondern $N+1$ viele Werte. Ansonsten verhält sich \texttt{my\_list} wie eine ganz \enquote{normale} Variable. 
Als Einträge einer Liste sind beliebige Werte mit beliebigen Datentypen zugelassen. 


\vspace{12pt}

\pause

\textbf{Frage:} Welchen Datentyp hat die Liste \py{[2, 2.3, "Hello"]} ? 
	
\end{fragile}

\begin{frame}
	
\begin{block}{Auf Listenelemente zugreifen}
	
	\vspace{2pt}
	
	Auf das \pybw{n}-te Element der Liste \py{my_list} kann man mittels \py{my_list[n]} zugreifen. 
	
	\pause 
	
    Mit \py{my_list[-1]} , \py{my_list[-2]}, etc. kann man auf das letzte, vorletzte, etc. Element von \pybw{my_list} zugreifen. 
		
\end{block}

\pause 
\vspace{12pt}

\begin{alertblock}{Achtung}
\vspace{2pt}
Python fängt bei 0 an zu zählen. D.h. das erste Element in der Liste hat den Index 0. \\
Beispiel: \py{my_list[1]} liefert das \emph{zweite} Element der Liste. 
\end{alertblock}

	
\end{frame}	


\begin{frame}
\begin{block}{Schreibzugriff auf Listenelemente}
\vspace{2pt}
Nach dem gleichen Prinzip lassen sich einzelne Listeneinträge verändern. \\
Beispiel: \py{my_list[3] = -23}. 
\end{block}

\pause 
\vspace{12pt}



\begin{alertblock}{Achtung}
\vspace{2pt}
Man kann nur schon existierende Listeneinträge verändern. 
\end{alertblock}

\pause 
\vspace{12pt}



\begin{exampleblock}{Neues Konzept}
\vspace{2pt}
Listen sind der erste Datentyp, den wir kennenlernen, der \emph{mutable} (veränderbar) ist. Die bisherigen Datentypen waren \emph{immutable}, d.h. man konnte sie zwar überschreiben, aber nicht verändern. 
\end{exampleblock}

\end{frame}

\begin{frame}
	
\begin{block}{Listeneinträge hinzufügen}
	\vspace{2pt}
	Mit der \emph{Methode} \pybw{.append()} kann ein Eintrag zur Liste hinzugefügt werden. \\ 
	Bsp: \py{my_list.append(12)} fügt einen weiteren Eintrag mit Wert \pybw{12} hinzu. 
\end{block}	

\pause 
\vspace{12pt}


\begin{block}{Listeneinträge entfernen}
\vspace{2pt}
Mit dem Keyword \pybw{del} kann man Einträge an einer bestimmten Position löschen. Dabei verschieben sich die darauffolgenden Einträge um \pybw{1} nach vorne. \\
Beispiel: \py{del my_list[2]} löscht das dritte Element.  

\pause 

Mit der Methode \pybw{.remove()} kann man Einträge mit einem bestimmten Wert löschen. \\
Beispiel: \py{my_list.remove(-23)} entfernt alle Einträge mit dem Wert \pybw{23}. Ist der Wert nicht vorhanden gibt es eine Fehlermeldung. 
\end{block}
\end{frame}

\begin{frame}{Übung}

\begin{block}{Das Eingangsproblem}
\vspace{2pt}
Schreibe ein kleines Programm, dass solange Deine Noten einliest, bist Du \pybw{q} drückst. Danach sollst Du die Möglichkeit haben, eine Zahl \pybw{k} einzugeben, so dass Dir die \pybw{k}-te Note angezeigt wird. 
\end{block}	
	
\end{frame}

	




