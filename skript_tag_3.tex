\section{Die For-Schleife \\ \footnotesize Einen Programmabschnitt x-mal ausführen}

\begin{frame}

\begin{block}{Problemstellung}
\vspace{2pt}
Lies eine ganze Zahl \py{x} ein. Gib dann folgende Zeilen auf der Konsole aus 

\texttt{1}\\
\texttt{2}\\
\texttt{3}\\
\texttt{4}\\
\vdots \\
\texttt{x}

\vspace{12pt}
Wie macht man das? 

\end{block}
\end{frame}

\begin{fragile}{}
	\begin{block}{Lösung \footnotesize (fast)}
		\begin{minted}{python}
			x = input("Enter a number")
			x = int(x)
			
			for k in range(1, x):	
			  print(k)
		\end{minted}
	\end{block}
\end{fragile}

\begin{frame}

	\renewcommand{\baselinestretch}{1.5}
	\metroset{block=fill}
	\begin{block}{Struktur der \texttt{for...in} Schleife}
		\vspace{2pt}
		\pause \py{for} \pause \textit{Variable} \pause \py{in} \pause \py{range}(\textit{min}, \textit{max})\pause\texttt{:} \pause \\
		\spacechar\spacechar Codezeile 1 \pause \\ 
\spacechar\spacechar Codezeile 2 \pause \\
\spacechar\spacechar \phantom{Code} \vdots \pause  \\
\textit{Code, der nicht mehr Teil der Schleife ist}
	\end{block}

\vspace{12pt}
\pause 

\metroset{block=transparent}
	\renewcommand{\baselinestretch}{1}
	\begin{block}{Wie funktioniert's?}
		\vspace{2pt}
	Die Schleifenvariable wird zunächst gleich dem unteren Wert in \py{range} gesetzt. Dann wird der \pybw{for}-Block wiederholt ausgeführt. Bei jedem Durchgang wird die Schleifenvariable um \pybw{1} vergrößert und zwar so lange, wie der Wert der Schleifenvariable kleiner als der obere Wert in \py{range} ist. 	
	\end{block}
\end{frame}

\begin{frame}
\begin{block}{Good to know}
	\pause
	\begin{itemize}[<+->]
		\item Achtung: Die Schleifenvariable erreicht nie das obere Ende der \py{range}-Funktion, sondern bleibt immer \pybw{1} drunter. 
		\item Die \py{range}-Funktion ist nicht auf 1er-Schrittweite beschränkt. Mit folgendem Ausdruck werden die Zahlen von \py{0} bis \py{9} z.B. in 3er-Schritten durchlaufen: \py{range(0, 10, 3)}. 
		\item \texttt{For}-Schleifen sind flexibel und können alles mögliche durchlaufen, z.B. auch die einzelnen Buchstaben eines Strings (dazu später mehr).
	\end{itemize}
\end{block}
\end{frame}

\begin{fragile}[Übung]

\begin{block}{Einmaleins: Die 7er-Reihe}
	\vspace{2pt}
Schreibe ein kleines Skript, was die 7er-Reihe (bis 70) wie folgt auf der Konsole ausgibt: 

\texttt{1 mal 7 ist 7}\\	
\texttt{2 mal 7 ist 14}\\
\phantom{4 mal} \vdots  
\end{block}

\vspace{12pt}

\begin{solutionblock}{Lösung}
\begin{minted}{python}
for k in range(1, 10 + 1):
  print(f"{k} mal 7 ist {7 * k}")
\end{minted}
\end{solutionblock}

\end{fragile}



\begin{fragile}[Übung]


\begin{block}{7er-Reihe mit beliebigem oberen Ende}
\vspace{2pt}
Lies eine positive ganze Zahl \py{x} ein und gib die 7er-Reihe von \py{7} bis mindestens \py{x} wie oben auf der Konsole aus.
\end{block}

\vspace{12pt}
\begin{solutionblock}{Lösung}
\begin{minted}{python}
limit = input("Bis wie weit soll die 7-er Reihe gezählt werden? ")
limit = int(limit)

limit = limit // 7 + 1
# man addiert 1, da man nach der Division aufrunden möchte.
# Ist limit eine 7er-Zahl zählt man halt ein bisschen zu weit

for k in range(1, limit + 1):
  print(f"{k} mal 7 ist {7 * k}")
\end{minted}
\end{solutionblock}


\end{fragile}

\begin{fragile}[Übung]
\begin{block}{Schleife über einen String}
\vspace{2pt}
Lies Deinen Namen (oder irgendein Wort) auf der Konsole ein und überprüfe, ob er den Buchstaben \emph{a} (groß/klein) enthält. 
\end{block}
\vspace{12pt}
\begin{solutionblock}{Lösung}
\begin{minted}{python}
name = input("Gib ein Wort ein: ")

# Flag (Schalter) initialisieren
name_contains_letter_a = False

for letter in name:
  if letter == "a" or letter == "A":
    name_contains_letter_a = True

if name_contains_letter_a:
  print("Der Name enthält ein 'a'.")
else:
  print("Der Name enthält kein 'a'.")
\end{minted}
\end{solutionblock}


\end{fragile}




\begin{fragile}[Schwierigere Übungen]

\begin{block}{Das Gauss-Problem}
\vspace{2pt}	
Berechne die Summe der Zahlen 1 bis 100. 
\end{block}
\vspace{12pt}
\begin{solutionblock}{Lösung}
\begin{minted}{python}
result = 0
for k in range(1, 100 + 1):
  result = result + k
print(f"Das Ergebnis ist {result}.")
\end{minted}
\end{solutionblock}



\end{fragile}

\begin{fragile}[Harte Übung I]

\begin{block}{Quersumme}
	\vspace{2pt}
	Lies eine ganze Zahl \py{x} ein und bestimme ihre Quersumme. 
	
	\textbf{Tipp 1:} Die Anzahl der Stellen einer Zahl bekommt man mittels \py{len(str(x))} heraus. \\
	\textbf{Tipp 2:} Man benötigt Tipp 1 gar nicht.  
	
\end{block}

\vspace{12pt}

\begin{solutionblock}{Lösung}
\begin{minted}{python}
number = input("Gib eine Zahl ein: ")
result = 0
# Wir lassen die Zahl als String, damit wir eine Schleife über die Ziffern legen können
for digit in number:
  result = result + int(digit)  # Achtung: digit ist ja eigentlich ein String

print(f"Die Quersumme von {number} ist {result}")
\end{minted}
\end{solutionblock}

\end{fragile}

\begin{fragile}[Harte Übung II]
\begin{block}{Zahlenmuster}
	\vspace{2pt}	
	Gib folgendes Muster auf der Konsole aus: 
	
	\texttt{1} \\
	\texttt{1 2} \\
	\texttt{1 2 3} \\
	\texttt{1 2 3 4} \\
	\phantom{1 2 } \vdots \\
	\texttt{1 2 $\cdots$ 20}
\end{block}

\begin{solutionblock}{Lösung}
\begin{minted}{python}
for row in range(1, 20 + 1):
  row_string = ""  # Hier wird das Ergebnis pro Zeile initialisiert
  for column in range(1, row +1):
    row_string = row_string + str(column) + " "
  print(row_string)
\end{minted}
\end{solutionblock}

\end{fragile}

\begin{fragile}[Brutale Übung]
	
	
	\begin{block}{Fibonacci-Zahlen}
		\vspace{2pt}
		Die Zahlenfolge $1,1,2,3,5,8,13\ldots$ nennt man \emph{Fibonacci}-Folge. Dabei ensteht ein Element der Folge, durch die Addition des vorherigen und vorvorherigen Elements. 
		
		\vspace{1pt}
		
		Berechne die 30. Fibonacci-Zahl.  
	\end{block}
	\vspace{12pt}
	\begin{solutionblock}{Lösung}
		\begin{minted}{python}
		last = 1  # letzte Zahl
		current = 1  # aktuelle Zahl
		
		for k in range(2, 30 + 1):
		old_current = current  # Zahl zwischenspeichern
		current = current + last
		last = old_current
		print(f"Die {k}-te Fibonacci-Zahl ist {current}")
		\end{minted}
	\end{solutionblock}
	
	
\end{fragile}


\section{Die While-Schleife \\ \footnotesize Wie die For-Schleife nur abstrakter und open-end}

\begin{frame}
\begin{block}{Problemstellung}
	\vspace{2pt}
	Lies immer wieder eine Zahl von der Konsole ein. Höre auf, wenn diese Zahl 7 ist. 
	
	Wie macht man das? 
\end{block}
\end{frame}

\begin{fragile}
	
\begin{block}{Lösung}
		\vspace{2pt}
		
	\begin{minted}{python}
		x = 0
		
		while x != 7: 
		  x = input("Enter a number")
		  x = int(x)
		  
		print("Yeah, you picked the right number.")
	\end{minted}
	
\end{block}
\end{fragile}


\begin{frame}

\renewcommand{\baselinestretch}{1.5}
\metroset{block=fill}
\begin{block}{Struktur der \texttt{while}-Schleife}
	\vspace{2pt}
	\pause \py{while} \pause \textit{Bedingung}\pause\texttt{:} \pause \\
	\spacechar\spacechar Codezeile 1 \pause \\ 
	\spacechar\spacechar Codezeile 2 \pause \\
	\spacechar\spacechar \phantom{Code} \vdots \pause  \\
	\textit{Code, der nicht mehr Teil der Schleife ist}
\end{block}
\vspace{12pt}
\pause 
\metroset{block=transparent}
\renewcommand{\baselinestretch}{1}
\begin{block}{Wie funktioniert's?}
	\vspace{2pt}
	Die Schleife wird solange ausgeführt, solange die \emph{Bedingung} \py{True} ergibt. Nach jedem Durchgang wird der Ausdruck der \emph{Bedingung} neu ausgewertet. 
	Ist die Bedingung \py{False} wird der Code unterhalb des Schleifenblocks ausgeführt. 
\end{block}

\end{frame}

\begin{frame}
\begin{alertblock}{Achtung Endlosschleife}
	\vspace{2pt}
	Man sollte immer darauf achten, dass die Bedingung in der \pybw{while}-Schleife auch wirklich irgendwannmal \py{False} wird. Ansonsten bleibt das Programm in einer \emph{Endlosschleife} gefangen. 
\end{alertblock}
\end{frame}


\begin{fragile}{Übung}

\begin{block}{Ersetze eine \pybw{for}-Schleife durch eine \pybw{while}-Schleife}
\vspace{2pt}
Schreib ein Programm, dass alle 7er-Zahlen von 7 bis 700 auf der Konsole ausgibt. 

\begin{solutionblock}{Lösung}
\begin{minted}{python}
k = 7
while k <= 70:
  print(k)
  k = k + 7
\end{minted}
\end{solutionblock}
 
\end{block}

\end{fragile}




%\begin{frame}{Übung}
%
%\begin{block}{Notenrechner}
%\vspace{2pt}
%Schreib ein Programm, dass wiederholt nach einer Note von Dir fragt und Dir dann jeweils die aktuelle Durchschnittsnote auf der Konsole ausgibt. 
%Das Programm soll durch die Eingabe vom Buchstaben \textbf{q} beendet werden können. 
%
%Beispielausgabe: 
%
%\texttt{Bitte gib eine Note oder q zum Beenden ein:} \py{1} \\
%\texttt{Deine Durchschnittsnote ist 1.0} \\
%\texttt{Bitte gib eine Note oder q zum Beenden ein:} \py{2} \\
%\texttt{Deine Durschnittsnote ist 1.5} \\
%\phantom{Code} \vdots 
%	
%\end{block}
%
%\end{frame}

\begin{frame}{Übung}

\begin{block}{Ratespiel}
\vspace{2pt}
Definiere eine positive ganze Zahl \pybw{number_to_guess}. Der User kann nun wiederholt eine Zahl eingeben. Das Spiel endet, wenn die eingegebene Zahl mit \pybw{number_to_guess} übereinstimmt. 
Andernfalls wird auf der Konsole beispielsweise ausgegeben: 

\texttt{Sorry, Deine eingegebene Zahl war zu klein, versuche es nochmal: }

\pause
\textbf{Zusatz 1:} \\
Am Ende soll die Anzahl der Versuche angegeben werden.

\pause
\textbf{Zusatz 2:} \\
Das Spiel soll mit der Eingabe von \pybw{q} abgebrochen werden können. 

\pause
\textbf{Zusatz 3:} \\
Google, wie Python die Zahl \pybw{number_to_guess} zufällig erzeugen kann (das verbessert das Gameplay).  

\end{block}
\end{frame}



\begin{frame}<beamer:0>[fragile]
\frametitle{Lösung}
\begin{solutionblock}{Ratespiel ohne Zusätze}
\begin{minted}{python}
number_to_guess = 512
guess = input("Rate meine Zahl: ")
guess = int(guess)

while guess != number_to_guess:
  if guess < number_to_guess:
    print("Deine Zahl war zu klein")
  else:
    print("Deine Zahl war zu groß")
  guess = input("Versuch's nochmal: ")
  guess = int(guess)

print("Du hast gewonnen")
\end{minted}
\end{solutionblock}
\end{frame}


\begin{frame}<beamer:0>[fragile]
\frametitle{Lösung}
\begin{solutionblock}{Ratespiel mit Zusatz 1}
\begin{minted}{python}
number_to_guess = 512
guess = input("Rate meine Zahl: ")
guess = int(guess)
counter = 1

while guess != number_to_guess:
  if guess < number_to_guess:
    print("Deine Zahl war zu klein")
  else:
    print("Deine Zahl war zu groß")
  guess = input("Versuch's nochmal: ")
  guess = int(guess)
  counter = counter + 1
  
print(f"Du hast nach {counter} Versuchen gewonnen")	
\end{minted}
\end{solutionblock}
\end{frame}


\begin{frame}<beamer:0>[fragile]
\frametitle{Lösung}
\begin{solutionblock}{Ratespiel mit Zusatz 2}
\begin{minted}{python}
number_to_guess = 512
counter = 1
guess = input("Rate meine Zahl: ")
guess = int(guess)
is_quit = False

while guess != number_to_guess and not is_quit:
  if guess < number_to_guess:
    print("Deine Zahl war zu klein")
  else:
    print("Deine Zahl war zu groß")
  guess = input("Versuch's nochmal: ")
  if guess == "q":
    is_quit = True
  else: 
    guess = int(guess)
  counter = counter + 1

if number_to_guess == guess: 
  print(f"Du hast nach {counter} Versuchen gewonnen")	
\end{minted}
\end{solutionblock}
\end{frame}




\begin{frame}<beamer:0>[fragile]
\frametitle{Lösung}
\begin{solutionblock}{Ratespiel mit Zusatz 3}
\begin{minted}{python}
import random 

number_to_guess = random.randint(1, 1000)
guess = input("Rate meine Zahl: ")
guess = int(guess)
# ... usw. 
\end{minted}
\end{solutionblock}
\end{frame}







	




