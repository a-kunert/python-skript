\section{Script Mode}
\begin{frame}
\begin{block}{Script Mode}
	\vspace{2pt}
	Sobald man mehrere zusammenhängende Zeilen hat, wird die REPL sehr unübersichtlich. Daher gibt es auch die Möglichkeit, alle Programmzeilen zunächst aufzuschreiben und diese dann gebündelt von Python ausführen zu lassen. Im Gegensatz zum REPL bzw. interactive Mode von Python wird dies \emph{Script Mode} genannt.    
\end{block}
\end{frame}

\begin{fragile}[]
\begin{exampleblock}{Beispiel}
\begin{minted}{python}
name = "Max"
age = 20
print(f"Hello, I'm {name} and I'm {age} years old") 
\end{minted}
\end{exampleblock}
\pause
\begin{alertblock}{Problem:}
\vspace{2pt}
Wie kann man Python erklären, diese 3 Zeilen auf einmal auszuführen? 
\end{alertblock}
\end{fragile}

\begin{frame}
\begin{block}{Old-School-Lösung}
\vspace{2pt}
\begin{itemize}
	\item Erstelle eine neue Datei (z.B. \pybw{my_script.py})
	\item Öffne die Datei mit einem Texteditor und speichere den Beispiel-Code darin ab.
	\item Öffne den Ordner mit der Datei \pybw{my_script.by} mit dem Terminal bzw. der Eingabeaufforderung
	\item Führe das Kommando \pybw{python my_script.py} aus. 
\end{itemize}
\end{block}
\end{frame}

\begin{frame}
\begin{block}{Optimallösung: Verwende eine IDE}
	\vspace{2pt}	
	Eine IDE (integrierte Entwicklungsumgebung) hilft Dir beim Programmieren und unterstüzt Dich wo immer möglich. Dadurch lassen sich auch große Projekte schnell umsetzen. 
\end{block}
\pause 

\vspace{12pt}

\begin{alertblock}{Nachteile}
	\vspace{2pt}
	Die anfängliche Einrichtung kann schnell kompliziert werden. Aufgrund der vielen Features fühlt man sich schnell mal überfordert. 
	\pause 
	
	$\rightarrow$ Das machen wir etwas später.	
\end{alertblock}
\end{frame}


\begin{frame}
\begin{block}{Kompromiss für den Anfang: Browserbasierte Editoren}
\vspace{2pt}
Um schnell einzusteigen, kann zu Beginn auch ein browsergestützter Editor/Interpreter verwendet werden. Zum Beispiel: 
\pause
\begin{itemize}
	\item Programiz (\texttt{https://www.programiz.com/python-programming/online-compiler})
	\begin{itemize}
		\item einfacher Einstieg
		\item schnell und unkompliziert
		\item geringer Funktionsumfang
	\end{itemize}
	\pause
	\item Repl.it (\texttt{https://replit.com/languages/python3})
	\begin{itemize}
		\item Auch für viele andere Sprachen geeignet
		\item Manchmal etwas langsam
		\item Man kann mehrere Dateien und Projekte verwalten (braucht Account) 
		\item Hat fast alle IDE-Features (braucht Account)
	\end{itemize}
%	\item Onecompiler (\texttt{https://onecompiler.com/python})
%	\begin{itemize}
%		\item Benötigt immer einen Account
%		\item Viele Funktionen
%	\end{itemize}
\end{itemize}
\end{block}

\end{frame}



\section{Input/Output \\ \footnotesize Kommunikation über die Konsole}


\begin{frame}

\begin{block}{Die Konsole}
\vspace{2pt}
Da wir zu Beginn noch über keine grafische Benutzeroberfläche verfügen, verwenden wir für die Kommunikation mit unserem Programm die \emph{Konsole}. 
Dabei handelt es sich um ein einfaches Textfenster, auf dem Dein Programm Informationen ausgeben kann (\emph{Output}) und Text einlesen kann (\emph{Input}). 
\end{block}

\end{frame}

\begin{fragile}[]
	
	\begin{block}{Output}
		\vspace{2pt}
		Um einen String auf der \emph{Konsole} auszugeben, verwende die Funktion \py{print()}. 
		
		
		Zum Beispiel: \py{print("Hello there")}. 
		\pause
		
		\vspace{12pt}
		
		Es können auch Variablen eingesetzt werden: 
		\begin{minted}{python}
		message = "Hello there"
		print(message) # Hello there
		\end{minted}
		
	\end{block}
	
\end{fragile}

\begin{fragile}[]
	
	\begin{block}{String Interpolation}
		\vspace{2pt}
		Um Variablenwerte innerhalb eines Strings auszugeben, verwenden wir die String-Interpolation-Syntax:
		\begin{minted}{python}
		my_value = 5
		print(f"The variable my_value has the value {my_value}")
		# The variable my_value has the value 5
		\end{minted}
		
		\pause
		
		\vspace{12pt}
		
		Das geht auch als \textit{inline expression}: 
		\begin{minted}{python}
		print(f"The sum of 1 and 2 is {1+2}")
		# The sum of 1 and 2 is 3
		\end{minted}
		
	\end{block}
	
\end{fragile}

\begin{fragile}
	\begin{block}{Input}
		\vspace{2pt}
		Um einen String vom User einzulesen, verwende die Funktion \py{input()}:
		
		\begin{minted}{python}
		age = input("How old are you?")
		print(f"I am {age} years old")
		\end{minted}
	\end{block}
	\pause 
	\begin{alertblock}{Achtung}
		\vspace{2pt}
		Das Ergebnis von \py{input} hat stets den Datentyp \py{string} auch wenn Zahlen eingelesen werden. Gegebenenfalls muss das Ergebnis mittels \py{int()} oder \py{float()} in den gewünschten Typ umgewandelt werden. 	
	\end{alertblock}
	
\end{fragile}


\begin{fragile}[]
	\begin{exampleblock}{Beispiel: Input und Output kombiniert}
		\begin{minted}{python}
		name = input("What is your name?")
		age = input("What is your age?")
		print(f"Hello {name}, you are {age} years old") 
		\end{minted}
	\end{exampleblock}
\end{fragile}

\begin{frame}{Übung}
\begin{block}{Adressabfrage}
\vspace{2pt}
Schreibe ein kurzes Skript, dass Dich nach Deinem Namen, Alter und Adresse fragt. Wenn es alles eingelesen hat, soll es diese Infos in folgender Form auf der Konsole ausgeben: 	

\texttt{Hallo Max, schön dass Du da bist. Du bist 21 Jahre alt und wohnst in der Bismarckstraße 12 in Glücksstadt.}
\end{block}
\end{frame}


\begin{frame}{Übung}
\begin{block}{Blick in die Zukunft}
	\vspace{2pt}
Schreibe ein kurzes Skript, dass Dich nach Deinem Alter fragt. Daraufhin soll es auf der Konsole ausgeben, wie alt Du in 15 Jahren sein wirst. 
\end{block}
\end{frame}

\section{Kommentare}

\begin{fragile}


\begin{block}{Kommentare}
\vspace{2pt}
Alle Zeichen einer Zeile, die hinter einem \texttt{\#} (Hashtag) kommen, werden von Python ignoriert.
So lassen sich Kommentare im Quellcode platzieren. 
\end{block}

\vspace{12pt}

\pause
\begin{exampleblock}{Beispiel}
\begin{minted}{python}
print("This line will be printed")
# print("This line won't") 
\end{minted}
\end{exampleblock}

\end{fragile}



\section{Conditionals \\ \footnotesize Ein Programm verzweigen}

\begin{frame}
	\begin{block}{Problemstellung}
		\vspace{2pt}
		Lies eine Zahl \py{x} ein. In Abhängigkeit von \py{x} soll Folgendes ausgegeben werden: 
		
		\texttt{Die Zahl x ist größer als 0} 
		
		bzw. 
		
		\texttt{Die Zahl x ist kleiner 0}  
		\vspace{8pt}
		
		
		Wie macht man das?
		\end{block}
\end{frame}

\begin{fragile}
	
\begin{block}{Lösung \footnotesize(fast)}
\begin{minted}{python}
x = input("Gib eine Zahl x an")
x = int(x)

if x < 0:
  print("x ist größer 0")
else:
  print("x ist kleiner 0")
\end{minted}
\end{block}
	
\end{fragile}


\begin{frame}
\metroset{block=fill}


	\renewcommand{\baselinestretch}{1.5}
\begin{block}{Struktur \texttt{if-else} Statement}	
	\vspace{2pt}
	\uncover<+->{
	\uncover<+->{\texttt{if}} \uncover<+->{\textit{Bedingung}}\uncover<+->{\texttt{:}}\\
	\uncover<+->{\spacechar\spacechar }\uncover<+->{\textit{Codezeile A1}}	\\
	\uncover<+->{\spacechar\spacechar \textit{Codezeile A2}	\\
	\spacechar\spacechar \phantom{Code}\vdots}\\
	\uncover<+->{\texttt{else:}}\\
	\uncover<+->{\spacechar\spacechar \textit{Codezeile B1}	\\
				 \spacechar\spacechar \textit{Codezeile B2}	\\
				 \spacechar\spacechar \phantom{Code}\vdots}\\
	\uncover<+->{\textit{Codezeile C1}\\
	\phantom{Code}\vdots
}
}
\end{block}
\renewcommand{\baselinestretch}{1}
%\vspace{10pt}

\end{frame}
\begin{frame}
\begin{block}{Wie funktioniert's?}
	\vspace{2pt}
Ist die \texttt{if}-Bedingung \py{True}, so wird der \texttt{if}-\textit{Block} ausgeführt. Ist sie \py{False} wird der \texttt{else}-\textit{Block} ausgeführt. 
\end{block}
\pause

\vspace{10pt}
\metroset{block=fill}
	\begin{block}{Definition: Block}
		\vspace{2pt}
		Aufeinanderfolgende Codezeilen, die alle die gleiche Einrückung besitzen, nennt man \emph{Block}. 
		D.h. Leerzeichen am Zeilenanfang haben in Python eine syntaktische Bedeutung.  
	\end{block}


\pause 
\vspace{10pt}

\metroset{block=transparent}
\begin{block}{Good to know}
	\begin{itemize}
		\item Der \pybw{else}-Block ist optional.
		\item Falls die Bedingung nicht vom Typ \py{bool} ist, so wird sie implizit umgewandelt.  
	\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Übungen}

	\begin{block}{Volljährigkeit prüfen/Zutrittskontrolle}
		\vspace{2pt}
		Schreibe ein Skript, dass nach dem Alter eines Users fragt und überprüft, ob der User schon volljährig ist. Dementsprechend soll auf der Konsole entweder 
		
		\texttt{Willkommen}
		
		 oder
		 
		  \texttt{Du darfst hier nicht rein} 
		  
		  erscheinen.  
	\end{block}
\pause 
\vspace{12pt}
	\begin{block}{Teilbarkeit bestimmen}
		\vspace{2pt}
		Schreibe ein Skript, dass eine ganze Zahl einliest. Daraufhin soll auf der Konsole ausgegeben werden, ob die Zahl durch \pybw{7} teilbar ist. Beispiel: Ist die Eingabe 12, so ist die Ausgabe:   

		\texttt{Die Zahl 12 ist nicht durch 7 teilbar.}
	\end{block}

\end{frame}



\begin{frame}

\metroset{block=fill}
\uncover<+->{\begin{block}{Logische Operatoren}
	\vspace{2pt}
Booleans können mittels folgender Operatoren miteinander verknüpft werden: 
\uncover<+->{
\begin{description}
	\item[\pybw{and}] Ist genau dann \py{True}, wenn beide Operanden \py{True} sind.
	\item[\pybw{or}] Ist genau dann \py{True}, wenn mindestens ein Operand \py{True} ist.
	\item[\pybw{not}] Kehrt den nachfolgenden Wahrheitswert um.  
\end{description}
} 
\end{block}}
\vspace{10pt}
\metroset{block=transparent}
\uncover<+->{\begin{exampleblock}{Beispiel}
\begin{itemize}
	\item \pybw{2 > 0 and 3 > 4} ist \py{False}
	\item \pybw{1 > 0 or 6 > 1} ist \py{True}
	\item \pybw{not 2 < 1} ist \py{True}
\end{itemize}
\end{exampleblock}
}
\end{frame}


\begin{frame}{Übung}
\uncover<+->{
\begin{block}{Was ergeben die folgenden Ausdrücke?}
	\begin{itemize}
		\item \py{not 2 < 3 and 4 < 7}
		\item \py{4 not == 8}
		\item \py{3 != 4 and not 4 == 8}
		\item \py{7 <= 7.0 and not 7 != 7.0}
		\item \py{7 > 5 or 4 < 5 and not 9 > 6}
		\item \py{not 3 < 6 > 8}
		\item \py{not 3}
	\end{itemize}
\end{block}
}
\uncover<+->{
\begin{alertblock}{Präzedenz beachten!}
	\begin{enumerate}
		\item \pybw{==}, \pybw{!=}, \pybw{<=}, \pybw{<}, \pybw{>}, \pybw{>=}
		\item \pybw{not}
		\item \pybw{and}
		\item \pybw{or}
	\end{enumerate}
\end{alertblock}
}

\end{frame}

\begin{fragile}

\begin{block}{Das \pybw{elif}-Statement}
	\vspace{2pt}
Mit der reinen \pybw{if-else}-Syntax können nur \emph{binäre} Verzweigungen dargestellt werden. Um mehrer, gleichrangige Verzweigungsäste zu realisieren kann man das \pybw{elif}-Conditional verwenden. 
\end{block}
\pause
\begin{exampleblock}{Beispiel}
\begin{minted}{python}
if x < 0: 
    print("x is < 0")
elif x == 0: 
    print("x is 0")
elif x == 1: 
    print("x is 1")
else: 
    print("x is not negative but neither 0 nor 1")         
\end{minted}
\end{exampleblock}
\pause
Die Anzahl der \pybw{elif}-Blöcke ist beliebig. Der \pybw{else}-Block ist wie immer optional. 

\end{fragile}

\begin{fragile}{Übung}
	\begin{block}{Worin unterscheiden sich die beiden Abschnitte?}
		\vspace{5pt}
		Abschnitt 1: 
		\begin{minted}{python}
		if x % 2 == 0: 
		   # some Code here
		if x % 3 == 0: 
		   # some Code here
		else: 
		   # some Code here  
		\end{minted}
		Abschnitt 2: 
		\begin{minted}{python}
		if x % 2 == 0: 
		# some Code here
		elif x % 3 == 0: 
		# some Code here
		else: 
		# some Code here  
		\end{minted}
	\end{block}
\end{fragile}

\begin{frame}{Übung}
\begin{block}{Baue einen Bestätigungsdialog}
\vspace{2pt}
Schreibe ein Skript was einen typischen Bestätigungsdialog simuliert. 
Zum Beispiel: 

\texttt{Are you sure to continue? (y)es/(n)o}. 

Mögliche Antworten sind \texttt{yes}, \texttt{no} bzw. \texttt{y}, \texttt{n}. 
Daraufhin soll auf der Konsole \texttt{confirmed} oder \texttt{aborted} erscheinen. 
\end{block}
\end{frame}

\begin{frame}{Komplexere Übung}
%\begin{block}{Berechne Deinen Urlaubsort}
%\vspace{2pt}
%\end{block}
\begin{center}
\includegraphics[width=0.5\textwidth]{urlaubsort.png}
\end{center}
Lies eine Zahl zwischen 1 und 9 ein und gib auf der Konsole \emph{deinen nächsten Urlaubsort} aus. 
\end{frame}


\begin{fragile}{}
\begin{block}{Der \emph{Ternary Operator}}
\vspace{2pt}
Oftmals möchte man eine Variable in Abhängigkeit eines Wahrheitswertes definieren. Für diesen einfachen Fall, ist das \pybw{if-else}-Konstrukt sehr umständlich. Stattdessen kann man für die Kürze den \emph{ternary operator} verwenden. 
\end{block}
\vspace{12pt}
\pause
\begin{exampleblock}{Beispiel}
	\vspace{2pt}
	\begin{minted}{python}
	if x < 0: 
	  sign = "sign"	
	else: 
	  sign = "positive"
	\end{minted}
\end{exampleblock}
\pause 
\begin{block}{Stattdessen mit Ternary Operator}
	\vspace{2pt}
	\py{sign = "negative" if x < 0 else "positive"}
\end{block}
\end{fragile}

\begin{frame}{Übung}

\begin{block}{}
	\vspace{2pt}
Lies eine ganze Zahl ein und gib ihren Betrag auf der Konsole aus. Schaffst Du es, das Ganze mit weniger als 5 Zeilen Code zu programmieren? 
\end{block}

\end{frame}

\section{Die For-Schleife \\ \footnotesize Einen Programmabschnitt x-mal ausführen}

\begin{frame}

\begin{block}{Problemstellung}
\vspace{2pt}
Lies eine ganze Zahl \py{x} ein. Gib dann folgende Zeilen auf der Konsole aus 

\texttt{1}\\
\texttt{2}\\
\texttt{3}\\
\texttt{4}\\
\vdots \\
\texttt{x}

\vspace{12pt}
Wie macht man das? 

\end{block}
\end{frame}

\begin{fragile}{}
	\begin{block}{Lösung}
		\begin{minted}{python}
			x = input("Enter a number")
			
			for k in range(1, x + 1):	
			  print(k)
		\end{minted}
	\end{block}
\end{fragile}

\begin{frame}

	\renewcommand{\baselinestretch}{1.5}
	\metroset{block=fill}
	\begin{block}{Struktur der \texttt{for...in} Schleife}
		\vspace{2pt}
		\pause \py{for} \pause \textit{Variable} \pause \py{in} \pause \py{range}(\textit{min}, \textit{max})\pause\texttt{:} \pause \\
		\spacechar\spacechar Codezeile 1 \pause \\ 
\spacechar\spacechar Codezeile 2 \pause \\
\spacechar\spacechar \phantom{Code} \vdots \pause  \\
\textit{Code, der nicht mehr Teil der Schleife ist}
	\end{block}

\vspace{12pt}
\pause 

\metroset{block=transparent}
	\renewcommand{\baselinestretch}{1}
	\begin{block}{Wie funktioniert's?}
		\vspace{2pt}
	Die Schleifenvariable wird zunächst gleich dem unteren Wert in \py{range} gesetzt. Dann wird der \pybw{for}-Block wiederholt ausgeführt. Bei jedem Durchgang wird die Schleifenvariable um \pybw{1} vergrößert und zwar so lange, wie der Wert der Schleifenvariable kleiner als der obere Wert in \py{range} ist. 	
	\end{block}
\end{frame}

\begin{frame}
\begin{block}{Good to know}
	\pause
	\begin{itemize}[<+->]
		\item Achtung: Die Schleifenvariable erreicht nie das obere Ende der \py{range}-Funktion, sondern bleibt immer \pybw{1} drunter. 
		\item Die \py{range}-Funktion ist nicht auf 1er-Schrittweite beschränkt. Mit folgendem Ausdruck werden die Zahlen von \py{0} bis \py{9} z.B. in 3er-Schritten durchlaufen: \py{range(0, 10, 3)}. 
		\item \texttt{For}-Schleifen sind flexibel und können alles mögliche durchlaufen, z.B. auch die einzelnen Buchstaben eines Strings (dazu später mehr).
	\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Übung}

\begin{block}{Einmaleins: Die 7er-Reihe}
	\vspace{2pt}
Schreibe ein kleines Skript, was die 7er-Reihe (bis 70) auf der Konsole ausgibt.	
\end{block}

\vspace{12pt}

\pause 

\begin{block}{7er-Reihe mit beliebigem oberen Ende}
	\vspace{2pt}
	Lies eine positive ganze Zahl \py{x} ein, gib die 7er-Reihe von \py{7} bis \py{x} auf der Konsole aus.  
\end{block}

\vspace{12pt}

\pause 

\begin{block}{7er-Reihe mit ganzen Sätzen}
	\vspace{2pt}
Lies wie eben eine obere Grenze für die 7-er Reihe ein. Gib dann die 7-er Reihe wie folgt auf der Konsole aus:

\texttt{1 mal 7 ist 7}\\	
\texttt{2 mal 7 ist 14}\\
\phantom{4 mal} \vdots

\end{block}
\end{frame}


\begin{frame}{Schwierigere Übungen}

\begin{block}{Das Gauss-Problem}
\vspace{2pt}	
Berechne die Summe der Zahlen 1 bis 100. 
\end{block}
\vspace{12pt}
\pause
\begin{block}{Zahlenmuster}
\vspace{2pt}	
Gib folgendes Muster auf der Konsole aus: 

\texttt{1} \\
\texttt{1 2} \\
\texttt{1 2 3} \\
\texttt{1 2 3 4} \\
\phantom{1 2 } \vdots \\
\texttt{1 2 $\cdots$ 20}
\end{block}

\end{frame}

\begin{frame}{Harte Übungen}

\begin{block}{Quersumme}
	\vspace{2pt}
	Lies eine ganze Zahl \py{x} ein und bestimme ihre Quersumme. 
	
	\textbf{Tipp 1:} Die Anzahl der Stellen einer Zahl bekommt man mittels \py{len(str(x))} heraus. \\
	\textbf{Tipp 2:} Man benötigt Tipp 1 gar nicht.  
	
\end{block}

\vspace{12pt}
\pause

\begin{block}{Primzahltest}
	\vspace{2pt}
	Lies eine ganze Zahl \py{x} ein und überprüfe, ob diese Zahl eine Primzahl ist. Das Programm soll etwa folgende Ausgabe liefern 
	
	\texttt{Die Zahl 28061983 ist eine Primzahl.}
\end{block}

\end{frame}


\section{Die While-Schleife \\ \footnotesize Wie die For-Schleife nur abstrakter und open-end}

\begin{frame}
\begin{block}{Problemstellung}
	\vspace{2pt}
	Lies immer wieder eine Zahl von der Konsole ein. Höre auf, wenn diese Zahl 7 ist. 
	
	Wie macht man das? 
\end{block}
\end{frame}

\begin{fragile}
	
\begin{block}{Lösung}
		\vspace{2pt}
		
	\begin{minted}{python}
		x = 0
		
		while x != 7: 
		  x = input("Enter a number")
		  x = int(x)
		  
		print("Yeah, you picked the right number.")
	\end{minted}
	
\end{block}
\end{fragile}


\begin{frame}

\renewcommand{\baselinestretch}{1.5}
\metroset{block=fill}
\begin{block}{Struktur der \texttt{While}-Schleife}
	\vspace{2pt}
	\pause \py{while} \pause \textit{Bedingung}\pause\texttt{:} \pause \\
	\spacechar\spacechar Codezeile 1 \pause \\ 
	\spacechar\spacechar Codezeile 2 \pause \\
	\spacechar\spacechar \phantom{Code} \vdots \pause  \\
	\textit{Code, der nicht mehr Teil der Schleife ist}
\end{block}
\vspace{12pt}
\pause 
\metroset{block=transparent}
\renewcommand{\baselinestretch}{1}
\begin{block}{Wie funktioniert's?}
	\vspace{2pt}
	Die Schleife wird solange ausgeführt, wie die \emph{Bedingung} \py{True} ergibt. Nach jedem Durchgang wird der Ausdruck der \emph{Bedingung} neu ausgewertet. 
	Ist die Bedingung \py{False} wird der Code unterhalb des Schleifenblocks ausgeführt. 
\end{block}

\end{frame}

\begin{frame}
\begin{alertblock}{Achtung Endlosschleife}
	\vspace{2pt}
	Man sollte immer darauf achten, dass die Bedingung in der \pybw{while}-Schleife auch wirklich irgendwannmal \py{False} wird. Ansonsten bleibt das Programm in einer \emph{Endlosschleife} gefangen. 
\end{alertblock}
\end{frame}

\begin{frame}{Übung}

\begin{block}{Ersetze eine \pybw{for}-Schleife durch eine \pybw{while}-Schleife}
\vspace{2pt}
Schreib ein Programm, dass alle 7er-Zahlen von 7 bis 700 auf der Konsole ausgibt.  
\end{block}

\pause 
\vspace{12pt}

\begin{block}{Bestätigungsdialog \emph{deluxe}}
\vspace{2pt}
Verbessere den Bestätigungsdialog:  

\texttt{Are you sure to continue? (y)es/(n)o}. 

Mögliche Antworten sind \texttt{yes}, \texttt{no} bzw. \texttt{y}, \texttt{n}. 

Daraufhin soll auf der Konsole \texttt{continued} oder \texttt{aborted} erscheinen. 
Falls die Eingabe nicht klar erkannt wird, soll die Frage nochmal auf der Konsole gestellt werden. 

Zum Beispiel: 
\texttt{Please enter either "yes"{} or "no"}  
\end{block}

\end{frame}

\begin{frame}{Übung}

\begin{block}{Notenrechner}
\vspace{2pt}
Schreib ein Programm, dass wiederholt nach einer Note von Dir fragt und Dir dann jeweils die aktuelle Durchschnittsnote auf der Konsole ausgibt. 
Das Programm soll durch die Eingabe vom Buchstaben \textbf{q} beendet werden können. 

Beispielausgabe: 

\texttt{Bitte gib eine Note oder q zum Beenden ein:} \py{1} \\
\texttt{Deine Durchschnittsnote ist 1.0} \\
\texttt{Bitte gib eine Note oder q zum Beenden ein:} \py{2} \\
\texttt{Deine Durschnittsnote ist 1.5} \\
\phantom{Code} \vdots 
	
\end{block}

\end{frame}

\begin{frame}{Übung}

\begin{block}{Ratespiel}
\vspace{2pt}
Definiere eine positive ganze Zahl \pybw{number_to_guess}. Der User kann nun wiederholt eine Zahl eingeben. Das Spiel endet, wenn die eingegebene Zahl mit \pybw{number_to_guess} übereinstimmt. 
Andernfalls wird auf der Konsole beispielsweise ausgegeben: 

\texttt{Sorry, Deine eingegebene Zahl war zu klein, versuche es nochmal: }

\pause
\textbf{Zusatz 1:} \\
Am Ende soll die Anzahl der Versuche angegeben werden.

\pause
\textbf{Zusatz 2:} \\
Das Spiel soll mit der Eingabe von q abgebrochen werden können. 

\pause
\textbf{Zusatz 3:} \\
Google, wie Python die Zahl \pybw{number_to_guess} zufällig erzeugen kann (das verbessert das Gameplay).  


\end{block}

\end{frame}