\documentclass[algorithm,pgfplots,colortheme=dark]{cuzbeamer}
\usepackage[ngerman]{babel}
\usepackage[scale=2]{ccicons}
\usepackage{listings}

\newcommand{\py}[1]{\mintinline{python}{#1}}
\newcommand{\pybw}[1]{\mintinline[style=bw]{python}{#1}}
\newcommand{\bash}[1]{\mintinline{bash}{#1}}


\begin{document}
\input{initialization.tex}
\maketitle



\input{skript_tag_1}


\section{Conditionals \\ \footnotesize Ein Programm verzweigen}

\begin{frame}
	\begin{block}{Problemstellung}
		\vspace{2pt}
		Lies eine Zahl \py{x} ein. In Abhängigkeit von \py{x} soll Folgendes ausgegeben werden: 
		
		\texttt{Die Zahl x ist größer als 0} 
		
		bzw. 
		
		\texttt{Die Zahl x ist kleiner 0}  
		\vspace{8pt}
		
		Wie macht man das?
		\end{block}
\end{frame}

\begin{fragile}
	
\begin{block}{Lösung \footnotesize(fast)}
\begin{minted}{python}
x = int(input("Gib eine Zahl x an"))

if x < 0:
	print("x ist größer 0")
else:
	print("x ist kleiner 0")
\end{minted}
\end{block}
	
\end{fragile}


\begin{frame}
\metroset{block=fill}


\begin{block}{Struktur if-else-statement}	
	\vspace{2pt}
	\uncover<+->{
	\uncover<+->{\texttt{if}} \uncover<+->{\textit{Bedingung}}\uncover<+->{\texttt{:}}\\
	\uncover<+->{\texttt{....}}\uncover<+->{\textit{Codezeile A1}}	\\
	\uncover<+->{\texttt{....}\textit{Codezeile A2}	\\
	\texttt{....}\phantom{Codezeile A}\vdots}\\
	\uncover<+->{\texttt{else:}}\\
	\uncover<+->{\texttt{....}\textit{Codezeile B1}	\\
				 \texttt{....}\textit{Codezeile B2}	\\
				 \texttt{....}\phantom{Codezeile B}\vdots}\\
	\uncover<+->{\textit{Codezeile C1}\\
	\phantom{Codezeile C}\vdots
}
}
\end{block}
\vspace{10pt}
\uncover<+->{
\begin{block}{Definition Block}
	\vspace{2pt}
	Aufeinanderfolgende Codezeilen, die alle die gleiche Einrückung besitzen, nennt man \textit{Block}. 
	D.h. Leerzeichen am Zeilenanfang haben in Python eine syntaktische Bedeutung.  
\end{block}
}
\end{frame}
\begin{frame}
\uncover<+->{
\begin{block}{Wie funktioniert's?}
	\vspace{2pt}
Ist die \texttt{if}-Bedingung \py{True}, so wird der \texttt{if}-\textit{Block} ausgeführt. Ist sie \py{False} wird der \texttt{else}-\textit{Block} ausgeführt 
\end{block}
}

\metroset{block=fill}

\vspace{10pt}

\metroset{block=transparent}
\uncover<+->{
\begin{block}{Good to know}
	\begin{itemize}
		\item Der \pybw{else}-Block ist optional.
		\item Falls die Bedingung nicht vom Typ \py{bool} ist, so wird sie implizit umgewandelt.  
	\end{itemize}
\end{block}
}
\end{frame}


\begin{frame}

\metroset{block=fill}
\uncover<+->{\begin{block}{Logische Operatoren}
	\vspace{2pt}
Booleans können mittels folgender Operatoren miteinander verknüpft werden
\begin{description}
	\item[\pybw{and}] Ist genau dann \py{True}, wenn beide Operanden \py{True} sind.
	\item[\pybw{or}] Ist genau dann \py{True}, wenn mindestens ein Operand \py{True} ist.
	\item[\pybw{not}] Kehrt den nachfolgenden Wahrheitswert um.  
\end{description}
\end{block}}
\vspace{10pt}
\metroset{block=transparent}
\uncover<+->{\begin{exampleblock}{Beispiel}
\begin{itemize}
	\item \pybw{2 > 0 and 3 > 4} ist \py{False}
	\item \pybw{1 > 0 or 6 > 1} ist \py{True}
	\item \pybw{not 2 < 1} ist \py{True}
\end{itemize}
\end{exampleblock}
}
\end{frame}


\begin{frame}{Übung}
\uncover<+->{
\begin{block}{Was ergeben die folgenden Ausdrücke?}
	\begin{itemize}
		\item \py{not 2 < 3 and 4 < 7}
		\item \py{4 not == 8}
		\item \py{3 != 4 and not 4 == 8}
		\item \py{7 <= 7.0 and not 7 != 7.0}
		\item \py{7 > 5 or 4 < 5 and not 9 > 6}
		\item \py{not 3 < 6 > 8}
		\item \py{not 3}
	\end{itemize}
\end{block}
}
\uncover<+->{
\begin{alertblock}{Präzedenz beachten!}
	\begin{enumerate}
		\item \pybw{==}, \pybw{!=}, \pybw{<=}, \pybw{<}, \pybw{>}, \pybw{>=}
		\item \pybw{not}
		\item \pybw{and}
		\item \pybw{or}
	\end{enumerate}
\end{alertblock}
}

\end{frame}

\end{document}






